// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "../winecore/Ownable.sol";
import "../wineaccesscontrol/WineryRole.sol";
import "../wineaccesscontrol/DistributorRole.sol";
import "../wineaccesscontrol/RetailerRole.sol";
import "../wineaccesscontrol/ConsumerRole.sol";

// Define a contract 'Supplychain'
contract SupplyChain is
    Ownable,
    WineryRole,
    DistributorRole,
    RetailerRole,
    ConsumerRole
{
    // Define a variable called 'upc' for Universal Product Code (UPC)
    uint256 upc;

    // Define a public mapping 'items' that maps the UPC to an Item.
    mapping(uint256 => Item) items;

    // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping(uint256 => string[]) itemsHistory;

    // Define enum 'State' with the following values:
    enum State {
        Bottled, // 0
        ForSale, // 1
        Sold, // 2
        Shipped, // 3
        Received, // 4
        ListedForSale, //5
        Purchased, // 6
        Opened //7
    }

    State constant defaultState = State.Bottled;

    // Define a struct 'Item' with the following fields:
    struct Item {
        //uint256 sku; // Stock Keeping Unit (SKU)
        uint256 upc; // Universal Product Code (UPC), generated by the Winery, goes on the bottle, can be verified by the Consumer
        address ownerID; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address originWineryID; // Metamask-Ethereum address of the Winery
        string originWineryName; // Winery Name
        string originWineryInformation; // Winery Information
        string originWineryLatitude; // Farm Latitude
        string originWineryLongitude; // Farm Longitude
        string wineDesc; // Product Notes
        uint256 price; // Product Price
        uint256 retailerPrice;
        State itemState; // Product State as represented in the enum above
        address distributorID; // Metamask-Ethereum address of the Distributor
        address retailerID; // Metamask-Ethereum address of the Retailer
        address consumerID; // Metamask-Ethereum address of the Consumer
    }

    // Define 8 events with the same 8 state values and accept 'upc' as input argument
    event Bottled(uint256 upc);
    event ForSale(uint256 upc);
    event Sold(uint256 upc);
    event Shipped(uint256 upc);
    event Received(uint256 upc);
    event ListedForSale(uint256 upc);
    event Purchased(uint256 upc);
    event Opened(uint256 upc);

    // Define a modifer that verifies the Caller
    modifier verifyCaller(address _address) {
        require(msg.sender == _address);
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint256 _price) {
        require(msg.value >= _price);
        _;
    }

    // Define a modifier that checks the price and refunds the remaining balance
    modifier checkValue(uint256 _price) {
        _;
        uint256 amountToReturn = msg.value - _price;
        payable(msg.sender).transfer(amountToReturn);
    }

    // Define a modifier that checks if an item.state of a upc is Harvested
    modifier bottled(uint256 _upc) {
        require(items[_upc].itemState == State.Bottled);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is ForSale
    modifier forSale(uint256 _upc) {
        require(items[_upc].itemState == State.ForSale);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Sold
    modifier sold(uint256 _upc) {
        require(items[_upc].itemState == State.Sold);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Shipped
    modifier shipped(uint256 _upc) {
        require(items[_upc].itemState == State.Shipped);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is Received
    modifier received(uint256 _upc) {
        require(items[_upc].itemState == State.Received);
        _;
    }

    modifier listedForSale(uint256 _upc) {
        require(items[_upc].itemState == State.ListedForSale);
        _;
    }
    // Define a modifier that checks if an item.state of a upc is Purchased
    modifier purchased(uint256 _upc) {
        require(items[_upc].itemState == State.Purchased);
        _;
    }

    modifier opened(uint256 _upc) {
        require(items[_upc].itemState == State.Opened);
        _;
    }

    // In the constructor set 'owner' to the address that instantiated the contract
    // and set 'sku' to 1
    // and set 'upc' to 1
    constructor() payable {
        //owner = msg.sender;
        //sku = 1;
        upc = 1;
    }

    // Define a function 'kill' if required
    function kill() public onlyOwner {
        selfdestruct(payable(owner()));
    }

    function bottleItem(
        address _originWineryID,
        string memory _originWineryName,
        string memory _originWineryInformation,
        string memory _originWineryLatitude,
        string memory _originWineryLongitude,
        string memory _wineDesc
    ) public onlyWinery {
        Item memory item = Item(
            upc,
            _originWineryID,
            _originWineryID,
            _originWineryName,
            _originWineryInformation,
            _originWineryLatitude,
            _originWineryLongitude,
            _wineDesc,
            0,
            0,
            defaultState,
            address(0),
            address(0),
            address(0)
        );

        items[upc] = item;
        emit Bottled(upc);
        upc = upc + 1;
    }

    // Define a function 'sellItem' that allows a winery to mark an item 'ForSale'
    function sellItem(uint256 _upc, uint256 _price)
        public
        bottled(_upc)
        onlyWinery
        verifyCaller(items[_upc].ownerID)
    {
        items[_upc].price = _price;
        items[_upc].itemState = State.ForSale;
        emit ForSale(_upc);
    }

    // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
    // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough,
    // and any excess ether sent is refunded back to the buyer
    function buyItem(uint256 _upc)
        public
        payable
        onlyDistributor
        // Call modifier to check if upc has passed previous supply chain stage
        forSale(_upc)
        // Call modifer to check if buyer has paid enough
        paidEnough(items[_upc].price)
        // Call modifer to send any excess ether back to buyer
        checkValue(items[_upc].price)
    {
        // Update the appropriate fields - ownerID, distributorID, itemState
        items[_upc].ownerID = msg.sender;
        items[_upc].distributorID = msg.sender;
        items[_upc].itemState = State.Sold;
        // Transfer money to farmer
        payable(items[_upc].originWineryID).transfer(items[_upc].price);
        // emit the appropriate event
        emit Sold(_upc);
    }

    // Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'
    // Use the above modifers to check if the item is sold
    function shipItem(uint256 _upc)
        public
        // Call modifier to check if upc has passed previous supply chain stage
        sold(_upc)
        // Call modifier to verify caller of this function
        onlyDistributor
        verifyCaller(items[_upc].ownerID)
    {
        // Update the appropriate fields
        items[_upc].itemState = State.Shipped;
        // Emit the appropriate event
        emit Shipped(_upc);
    }

    // Define a function 'receiveItem' that allows the retailer to mark an item 'Received'
    // Use the above modifiers to check if the item is shipped
    function receiveItem(uint256 _upc)
        public
        // Call modifier to check if upc has passed previous supply chain stage
        shipped(_upc)
        // Access Control List enforced by calling Smart Contract / DApp
        onlyRetailer
    {
        // Update the appropriate fields - ownerID, retailerID, itemState
        items[_upc].ownerID = msg.sender;
        items[_upc].retailerID = msg.sender;
        items[_upc].itemState = State.Received;
        // Emit the appropriate event
        emit Received(_upc);
    }

    function listForSale(uint256 _upc, uint256 _price)
        public
        received(_upc)
        onlyRetailer
        verifyCaller(items[_upc].ownerID)
    {
        items[_upc].retailerPrice = _price;
        items[_upc].itemState = State.ListedForSale;
        emit ListedForSale(_upc);
    }

    // Define a function 'purchaseItem' that allows the consumer to mark an item 'Purchased'
    // Use the above modifiers to check if the item is received
    function purchaseItem(uint256 _upc)
        public
        payable
        // Call modifier to check if upc has passed previous supply chain stage
        listedForSale(_upc)
        // Access Control List enforced by calling Smart Contract / DApp
        onlyConsumer
        paidEnough(items[_upc].retailerPrice)
        checkValue(items[_upc].retailerPrice)
    {
        // Update the appropriate fields - ownerID, consumerID, itemState
        items[_upc].ownerID = msg.sender;
        items[_upc].consumerID = msg.sender;
        items[_upc].itemState = State.Purchased;
        payable(items[_upc].retailerID).transfer(items[_upc].retailerPrice);
        // Emit the appropriate event
        emit Purchased(_upc);
    }

    function open(uint256 _upc)
        public
        purchased(_upc)
        onlyConsumer
        verifyCaller(items[_upc].ownerID)
    {
        items[_upc].itemState = State.Opened;
        emit Opened(_upc);
    }

    // Define a function 'fetchItemBufferOne' that fetches the data
    function fetchItemBufferOne(uint256 _upc)
        public
        view
        returns (
            uint256 itemUPC,
            address ownerID,
            address originWineryID,
            string memory originWineryName,
            string memory originWineryInformation,
            string memory originWineryLatitude,
            string memory originWineryLongitude
        )
    {
        itemUPC = _upc;
        ownerID = items[_upc].ownerID;
        originWineryID = items[_upc].originWineryID;
        originWineryName = items[_upc].originWineryName;
        originWineryInformation = items[_upc].originWineryInformation;
        originWineryLatitude = items[_upc].originWineryLatitude;
        originWineryLongitude = items[_upc].originWineryLongitude;

        return (
            itemUPC,
            ownerID,
            originWineryID,
            originWineryName,
            originWineryInformation,
            originWineryLatitude,
            originWineryLongitude
        );
    }

    // Define a function 'fetchItemBufferTwo' that fetches the data
    function fetchItemBufferTwo(uint256 _upc)
        public
        view
        returns (
            uint256 itemUPC,
            string memory wineDesc,
            uint256 price,
            uint256 retailerPrice,
            uint256 itemState,
            address distributorID,
            address retailerID,
            address consumerID
        )
    {
        itemUPC = _upc;
        wineDesc = items[_upc].wineDesc;
        price = items[_upc].price;
        retailerPrice = items[_upc].retailerPrice;
        itemState = uint256(items[_upc].itemState);
        distributorID = items[_upc].distributorID;
        retailerID = items[_upc].retailerID;
        consumerID = items[_upc].consumerID;

        return (
            itemUPC,
            wineDesc,
            price,
            retailerPrice,
            itemState,
            distributorID,
            retailerID,
            consumerID
        );
    }
}
